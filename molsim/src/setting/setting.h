// Copyright (c) 2005-2014 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

#ifndef SETTING_H
#define SETTING_H

#ifndef XSD_CXX11
#define XSD_CXX11
#endif

#ifndef XSD_USE_CHAR
#define XSD_USE_CHAR
#endif

#ifndef XSD_CXX_TREE_USE_CHAR
#define XSD_CXX_TREE_USE_CHAR
#endif

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/config.hxx>

#if (XSD_INT_VERSION != 4000000L)
#error XSD runtime version mismatch
#endif

#include <xsd/cxx/pre.hxx>

#include <xsd/cxx/xml/char-utf8.hxx>

#include <xsd/cxx/tree/exceptions.hxx>
#include <xsd/cxx/tree/elements.hxx>
#include <xsd/cxx/tree/types.hxx>

#include <xsd/cxx/xml/error-handler.hxx>

#include <xsd/cxx/xml/dom/auto-ptr.hxx>

#include <xsd/cxx/tree/parsing.hxx>
#include <xsd/cxx/tree/parsing/byte.hxx>
#include <xsd/cxx/tree/parsing/unsigned-byte.hxx>
#include <xsd/cxx/tree/parsing/short.hxx>
#include <xsd/cxx/tree/parsing/unsigned-short.hxx>
#include <xsd/cxx/tree/parsing/int.hxx>
#include <xsd/cxx/tree/parsing/unsigned-int.hxx>
#include <xsd/cxx/tree/parsing/long.hxx>
#include <xsd/cxx/tree/parsing/unsigned-long.hxx>
#include <xsd/cxx/tree/parsing/boolean.hxx>
#include <xsd/cxx/tree/parsing/float.hxx>
#include <xsd/cxx/tree/parsing/double.hxx>
#include <xsd/cxx/tree/parsing/decimal.hxx>

#include <xsd/cxx/xml/dom/serialization-header.hxx>
#include <xsd/cxx/tree/serialization.hxx>
#include <xsd/cxx/tree/serialization/byte.hxx>
#include <xsd/cxx/tree/serialization/unsigned-byte.hxx>
#include <xsd/cxx/tree/serialization/short.hxx>
#include <xsd/cxx/tree/serialization/unsigned-short.hxx>
#include <xsd/cxx/tree/serialization/int.hxx>
#include <xsd/cxx/tree/serialization/unsigned-int.hxx>
#include <xsd/cxx/tree/serialization/long.hxx>
#include <xsd/cxx/tree/serialization/unsigned-long.hxx>
#include <xsd/cxx/tree/serialization/boolean.hxx>
#include <xsd/cxx/tree/serialization/float.hxx>
#include <xsd/cxx/tree/serialization/double.hxx>
#include <xsd/cxx/tree/serialization/decimal.hxx>

namespace xml_schema
{
  // anyType and anySimpleType.
  //
  typedef ::xsd::cxx::tree::type type;
  typedef ::xsd::cxx::tree::simple_type< char, type > simple_type;
  typedef ::xsd::cxx::tree::type container;

  // 8-bit
  //
  typedef signed char byte;
  typedef unsigned char unsigned_byte;

  // 16-bit
  //
  typedef short short_;
  typedef unsigned short unsigned_short;

  // 32-bit
  //
  typedef int int_;
  typedef unsigned int unsigned_int;

  // 64-bit
  //
  typedef long long long_;
  typedef unsigned long long unsigned_long;

  // Supposed to be arbitrary-length integral types.
  //
  typedef long long integer;
  typedef long long non_positive_integer;
  typedef unsigned long long non_negative_integer;
  typedef unsigned long long positive_integer;
  typedef long long negative_integer;

  // Boolean.
  //
  typedef bool boolean;

  // Floating-point types.
  //
  typedef float float_;
  typedef double double_;
  typedef double decimal;

  // String types.
  //
  typedef ::xsd::cxx::tree::string< char, simple_type > string;
  typedef ::xsd::cxx::tree::normalized_string< char, string > normalized_string;
  typedef ::xsd::cxx::tree::token< char, normalized_string > token;
  typedef ::xsd::cxx::tree::name< char, token > name;
  typedef ::xsd::cxx::tree::nmtoken< char, token > nmtoken;
  typedef ::xsd::cxx::tree::nmtokens< char, simple_type, nmtoken > nmtokens;
  typedef ::xsd::cxx::tree::ncname< char, name > ncname;
  typedef ::xsd::cxx::tree::language< char, token > language;

  // ID/IDREF.
  //
  typedef ::xsd::cxx::tree::id< char, ncname > id;
  typedef ::xsd::cxx::tree::idref< char, ncname, type > idref;
  typedef ::xsd::cxx::tree::idrefs< char, simple_type, idref > idrefs;

  // URI.
  //
  typedef ::xsd::cxx::tree::uri< char, simple_type > uri;

  // Qualified name.
  //
  typedef ::xsd::cxx::tree::qname< char, simple_type, uri, ncname > qname;

  // Binary.
  //
  typedef ::xsd::cxx::tree::buffer< char > buffer;
  typedef ::xsd::cxx::tree::base64_binary< char, simple_type > base64_binary;
  typedef ::xsd::cxx::tree::hex_binary< char, simple_type > hex_binary;

  // Date/time.
  //
  typedef ::xsd::cxx::tree::time_zone time_zone;
  typedef ::xsd::cxx::tree::date< char, simple_type > date;
  typedef ::xsd::cxx::tree::date_time< char, simple_type > date_time;
  typedef ::xsd::cxx::tree::duration< char, simple_type > duration;
  typedef ::xsd::cxx::tree::gday< char, simple_type > gday;
  typedef ::xsd::cxx::tree::gmonth< char, simple_type > gmonth;
  typedef ::xsd::cxx::tree::gmonth_day< char, simple_type > gmonth_day;
  typedef ::xsd::cxx::tree::gyear< char, simple_type > gyear;
  typedef ::xsd::cxx::tree::gyear_month< char, simple_type > gyear_month;
  typedef ::xsd::cxx::tree::time< char, simple_type > time;

  // Entity.
  //
  typedef ::xsd::cxx::tree::entity< char, ncname > entity;
  typedef ::xsd::cxx::tree::entities< char, simple_type, entity > entities;

  typedef ::xsd::cxx::tree::content_order content_order;
  // Namespace information and list stream. Used in
  // serialization functions.
  //
  typedef ::xsd::cxx::xml::dom::namespace_info< char > namespace_info;
  typedef ::xsd::cxx::xml::dom::namespace_infomap< char > namespace_infomap;
  typedef ::xsd::cxx::tree::list_stream< char > list_stream;
  typedef ::xsd::cxx::tree::as_double< double_ > as_double;
  typedef ::xsd::cxx::tree::as_decimal< decimal > as_decimal;
  typedef ::xsd::cxx::tree::facet facet;

  // Flags and properties.
  //
  typedef ::xsd::cxx::tree::flags flags;
  typedef ::xsd::cxx::tree::properties< char > properties;

  // Parsing/serialization diagnostics.
  //
  typedef ::xsd::cxx::tree::severity severity;
  typedef ::xsd::cxx::tree::error< char > error;
  typedef ::xsd::cxx::tree::diagnostics< char > diagnostics;

  // Exceptions.
  //
  typedef ::xsd::cxx::tree::exception< char > exception;
  typedef ::xsd::cxx::tree::bounds< char > bounds;
  typedef ::xsd::cxx::tree::duplicate_id< char > duplicate_id;
  typedef ::xsd::cxx::tree::parsing< char > parsing;
  typedef ::xsd::cxx::tree::expected_element< char > expected_element;
  typedef ::xsd::cxx::tree::unexpected_element< char > unexpected_element;
  typedef ::xsd::cxx::tree::expected_attribute< char > expected_attribute;
  typedef ::xsd::cxx::tree::unexpected_enumerator< char > unexpected_enumerator;
  typedef ::xsd::cxx::tree::expected_text_content< char > expected_text_content;
  typedef ::xsd::cxx::tree::no_prefix_mapping< char > no_prefix_mapping;
  typedef ::xsd::cxx::tree::serialization< char > serialization;

  // Error handler callback interface.
  //
  typedef ::xsd::cxx::xml::error_handler< char > error_handler;

  // DOM interaction.
  //
  namespace dom
  {
    // Automatic pointer for DOMDocument.
    //
    using ::xsd::cxx::xml::dom::unique_ptr;

#ifndef XSD_CXX_TREE_TREE_NODE_KEY__XML_SCHEMA
#define XSD_CXX_TREE_TREE_NODE_KEY__XML_SCHEMA
    // DOM user data key for back pointers to tree nodes.
    //
    const XMLCh* const tree_node_key = ::xsd::cxx::tree::user_data_keys::node;
#endif
  }
}

// Forward declarations.
//
class thermo_target_t;
class thermo_t;
class setting_t;

#include <memory>    // ::std::unique_ptr
#include <limits>    // std::numeric_limits
#include <algorithm> // std::binary_search
#include <utility>   // std::move

#include <xsd/cxx/xml/char-utf8.hxx>

#include <xsd/cxx/tree/exceptions.hxx>
#include <xsd/cxx/tree/elements.hxx>
#include <xsd/cxx/tree/containers.hxx>
#include <xsd/cxx/tree/list.hxx>

#include <xsd/cxx/xml/dom/parsing-header.hxx>

class thermo_target_t: public ::xml_schema::type
{
  public:
  // target
  //
  typedef ::xml_schema::float_ target_type;
  typedef ::xsd::cxx::tree::traits< target_type, char > target_traits;

  const target_type&
  target () const;

  target_type&
  target ();

  void
  target (const target_type& x);

  // temperature_step
  //
  typedef ::xml_schema::float_ temperature_step_type;
  typedef ::xsd::cxx::tree::traits< temperature_step_type, char > temperature_step_traits;

  const temperature_step_type&
  temperature_step () const;

  temperature_step_type&
  temperature_step ();

  void
  temperature_step (const temperature_step_type& x);

  // timestep
  //
  typedef ::xml_schema::int_ timestep_type;
  typedef ::xsd::cxx::tree::traits< timestep_type, char > timestep_traits;

  const timestep_type&
  timestep () const;

  timestep_type&
  timestep ();

  void
  timestep (const timestep_type& x);

  // Constructors.
  //
  thermo_target_t (const target_type&,
                   const temperature_step_type&,
                   const timestep_type&);

  thermo_target_t (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

  thermo_target_t (const thermo_target_t& x,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

  virtual thermo_target_t*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  thermo_target_t&
  operator= (const thermo_target_t& x);

  virtual 
  ~thermo_target_t ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< target_type > target_;
  ::xsd::cxx::tree::one< temperature_step_type > temperature_step_;
  ::xsd::cxx::tree::one< timestep_type > timestep_;
};

class thermo_t: public ::xml_schema::type
{
  public:
  // initial
  //
  typedef ::xml_schema::float_ initial_type;
  typedef ::xsd::cxx::tree::traits< initial_type, char > initial_traits;

  const initial_type&
  initial () const;

  initial_type&
  initial ();

  void
  initial (const initial_type& x);

  // timestep
  //
  typedef ::xml_schema::int_ timestep_type;
  typedef ::xsd::cxx::tree::traits< timestep_type, char > timestep_traits;

  const timestep_type&
  timestep () const;

  timestep_type&
  timestep ();

  void
  timestep (const timestep_type& x);

  // heating
  //
  typedef ::thermo_target_t heating_type;
  typedef ::xsd::cxx::tree::optional< heating_type > heating_optional;
  typedef ::xsd::cxx::tree::traits< heating_type, char > heating_traits;

  const heating_optional&
  heating () const;

  heating_optional&
  heating ();

  void
  heating (const heating_type& x);

  void
  heating (const heating_optional& x);

  void
  heating (::std::unique_ptr< heating_type > p);

  // ignoreY
  //
  typedef ::xml_schema::boolean ignoreY_type;
  typedef ::xsd::cxx::tree::optional< ignoreY_type > ignoreY_optional;
  typedef ::xsd::cxx::tree::traits< ignoreY_type, char > ignoreY_traits;

  const ignoreY_optional&
  ignoreY () const;

  ignoreY_optional&
  ignoreY ();

  void
  ignoreY (const ignoreY_type& x);

  void
  ignoreY (const ignoreY_optional& x);

  // Constructors.
  //
  thermo_t (const initial_type&,
            const timestep_type&);

  thermo_t (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

  thermo_t (const thermo_t& x,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

  virtual thermo_t*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  thermo_t&
  operator= (const thermo_t& x);

  virtual 
  ~thermo_t ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< initial_type > initial_;
  ::xsd::cxx::tree::one< timestep_type > timestep_;
  heating_optional heating_;
  ignoreY_optional ignoreY_;
};

class setting_t: public ::xml_schema::type
{
  public:
  // outputname
  //
  typedef ::xml_schema::string outputname_type;
  typedef ::xsd::cxx::tree::traits< outputname_type, char > outputname_traits;

  const outputname_type&
  outputname () const;

  outputname_type&
  outputname ();

  void
  outputname (const outputname_type& x);

  void
  outputname (::std::unique_ptr< outputname_type > p);

  // endfile
  //
  typedef ::xml_schema::string endfile_type;
  typedef ::xsd::cxx::tree::optional< endfile_type > endfile_optional;
  typedef ::xsd::cxx::tree::traits< endfile_type, char > endfile_traits;

  const endfile_optional&
  endfile () const;

  endfile_optional&
  endfile ();

  void
  endfile (const endfile_type& x);

  void
  endfile (const endfile_optional& x);

  void
  endfile (::std::unique_ptr< endfile_type > p);

  // frequency
  //
  typedef ::xml_schema::int_ frequency_type;
  typedef ::xsd::cxx::tree::traits< frequency_type, char > frequency_traits;

  const frequency_type&
  frequency () const;

  frequency_type&
  frequency ();

  void
  frequency (const frequency_type& x);

  // profileFile
  //
  typedef ::xml_schema::string profileFile_type;
  typedef ::xsd::cxx::tree::optional< profileFile_type > profileFile_optional;
  typedef ::xsd::cxx::tree::traits< profileFile_type, char > profileFile_traits;

  const profileFile_optional&
  profileFile () const;

  profileFile_optional&
  profileFile ();

  void
  profileFile (const profileFile_type& x);

  void
  profileFile (const profileFile_optional& x);

  void
  profileFile (::std::unique_ptr< profileFile_type > p);

  // profileBucketsX
  //
  typedef ::xml_schema::int_ profileBucketsX_type;
  typedef ::xsd::cxx::tree::optional< profileBucketsX_type > profileBucketsX_optional;
  typedef ::xsd::cxx::tree::traits< profileBucketsX_type, char > profileBucketsX_traits;

  const profileBucketsX_optional&
  profileBucketsX () const;

  profileBucketsX_optional&
  profileBucketsX ();

  void
  profileBucketsX (const profileBucketsX_type& x);

  void
  profileBucketsX (const profileBucketsX_optional& x);

  // delta_t
  //
  typedef ::xml_schema::float_ delta_t_type;
  typedef ::xsd::cxx::tree::traits< delta_t_type, char > delta_t_traits;

  const delta_t_type&
  delta_t () const;

  delta_t_type&
  delta_t ();

  void
  delta_t (const delta_t_type& x);

  // t_end
  //
  typedef ::xml_schema::float_ t_end_type;
  typedef ::xsd::cxx::tree::traits< t_end_type, char > t_end_traits;

  const t_end_type&
  t_end () const;

  t_end_type&
  t_end ();

  void
  t_end (const t_end_type& x);

  // b_factor
  //
  typedef ::xml_schema::float_ b_factor_type;
  typedef ::xsd::cxx::tree::traits< b_factor_type, char > b_factor_traits;

  const b_factor_type&
  b_factor () const;

  b_factor_type&
  b_factor ();

  void
  b_factor (const b_factor_type& x);

  // g_grav_x
  //
  typedef ::xml_schema::float_ g_grav_x_type;
  typedef ::xsd::cxx::tree::traits< g_grav_x_type, char > g_grav_x_traits;

  const g_grav_x_type&
  g_grav_x () const;

  g_grav_x_type&
  g_grav_x ();

  void
  g_grav_x (const g_grav_x_type& x);

  // g_grav_y
  //
  typedef ::xml_schema::float_ g_grav_y_type;
  typedef ::xsd::cxx::tree::traits< g_grav_y_type, char > g_grav_y_traits;

  const g_grav_y_type&
  g_grav_y () const;

  g_grav_y_type&
  g_grav_y ();

  void
  g_grav_y (const g_grav_y_type& x);

  // g_grav_z
  //
  typedef ::xml_schema::float_ g_grav_z_type;
  typedef ::xsd::cxx::tree::traits< g_grav_z_type, char > g_grav_z_traits;

  const g_grav_z_type&
  g_grav_z () const;

  g_grav_z_type&
  g_grav_z ();

  void
  g_grav_z (const g_grav_z_type& x);

  // domainX
  //
  typedef ::xml_schema::float_ domainX_type;
  typedef ::xsd::cxx::tree::traits< domainX_type, char > domainX_traits;

  const domainX_type&
  domainX () const;

  domainX_type&
  domainX ();

  void
  domainX (const domainX_type& x);

  // domainY
  //
  typedef ::xml_schema::float_ domainY_type;
  typedef ::xsd::cxx::tree::traits< domainY_type, char > domainY_traits;

  const domainY_type&
  domainY () const;

  domainY_type&
  domainY ();

  void
  domainY (const domainY_type& x);

  // domainZ
  //
  typedef ::xml_schema::float_ domainZ_type;
  typedef ::xsd::cxx::tree::traits< domainZ_type, char > domainZ_traits;

  const domainZ_type&
  domainZ () const;

  domainZ_type&
  domainZ ();

  void
  domainZ (const domainZ_type& x);

  // r_cutoff
  //
  typedef ::xml_schema::float_ r_cutoff_type;
  typedef ::xsd::cxx::tree::traits< r_cutoff_type, char > r_cutoff_traits;

  const r_cutoff_type&
  r_cutoff () const;

  r_cutoff_type&
  r_cutoff ();

  void
  r_cutoff (const r_cutoff_type& x);

  // ContainerType
  //
  typedef ::xml_schema::int_ ContainerType_type;
  typedef ::xsd::cxx::tree::optional< ContainerType_type > ContainerType_optional;
  typedef ::xsd::cxx::tree::traits< ContainerType_type, char > ContainerType_traits;

  const ContainerType_optional&
  ContainerType () const;

  ContainerType_optional&
  ContainerType ();

  void
  ContainerType (const ContainerType_type& x);

  void
  ContainerType (const ContainerType_optional& x);

  // ForceComputationMethod
  //
  typedef ::xml_schema::int_ ForceComputationMethod_type;
  typedef ::xsd::cxx::tree::optional< ForceComputationMethod_type > ForceComputationMethod_optional;
  typedef ::xsd::cxx::tree::traits< ForceComputationMethod_type, char > ForceComputationMethod_traits;

  const ForceComputationMethod_optional&
  ForceComputationMethod () const;

  ForceComputationMethod_optional&
  ForceComputationMethod ();

  void
  ForceComputationMethod (const ForceComputationMethod_type& x);

  void
  ForceComputationMethod (const ForceComputationMethod_optional& x);

  // bc_left
  //
  typedef ::xml_schema::int_ bc_left_type;
  typedef ::xsd::cxx::tree::traits< bc_left_type, char > bc_left_traits;

  const bc_left_type&
  bc_left () const;

  bc_left_type&
  bc_left ();

  void
  bc_left (const bc_left_type& x);

  // bc_upper
  //
  typedef ::xml_schema::int_ bc_upper_type;
  typedef ::xsd::cxx::tree::traits< bc_upper_type, char > bc_upper_traits;

  const bc_upper_type&
  bc_upper () const;

  bc_upper_type&
  bc_upper ();

  void
  bc_upper (const bc_upper_type& x);

  // bc_right
  //
  typedef ::xml_schema::int_ bc_right_type;
  typedef ::xsd::cxx::tree::traits< bc_right_type, char > bc_right_traits;

  const bc_right_type&
  bc_right () const;

  bc_right_type&
  bc_right ();

  void
  bc_right (const bc_right_type& x);

  // bc_lower
  //
  typedef ::xml_schema::int_ bc_lower_type;
  typedef ::xsd::cxx::tree::traits< bc_lower_type, char > bc_lower_traits;

  const bc_lower_type&
  bc_lower () const;

  bc_lower_type&
  bc_lower ();

  void
  bc_lower (const bc_lower_type& x);

  // bc_front
  //
  typedef ::xml_schema::int_ bc_front_type;
  typedef ::xsd::cxx::tree::traits< bc_front_type, char > bc_front_traits;

  const bc_front_type&
  bc_front () const;

  bc_front_type&
  bc_front ();

  void
  bc_front (const bc_front_type& x);

  // bc_back
  //
  typedef ::xml_schema::int_ bc_back_type;
  typedef ::xsd::cxx::tree::traits< bc_back_type, char > bc_back_traits;

  const bc_back_type&
  bc_back () const;

  bc_back_type&
  bc_back ();

  void
  bc_back (const bc_back_type& x);

  // inputfiles
  //
  typedef ::xml_schema::string inputfiles_type;
  typedef ::xsd::cxx::tree::sequence< inputfiles_type > inputfiles_sequence;
  typedef inputfiles_sequence::iterator inputfiles_iterator;
  typedef inputfiles_sequence::const_iterator inputfiles_const_iterator;
  typedef ::xsd::cxx::tree::traits< inputfiles_type, char > inputfiles_traits;

  const inputfiles_sequence&
  inputfiles () const;

  inputfiles_sequence&
  inputfiles ();

  void
  inputfiles (const inputfiles_sequence& s);

  // thermostat
  //
  typedef ::thermo_t thermostat_type;
  typedef ::xsd::cxx::tree::optional< thermostat_type > thermostat_optional;
  typedef ::xsd::cxx::tree::traits< thermostat_type, char > thermostat_traits;

  const thermostat_optional&
  thermostat () const;

  thermostat_optional&
  thermostat ();

  void
  thermostat (const thermostat_type& x);

  void
  thermostat (const thermostat_optional& x);

  void
  thermostat (::std::unique_ptr< thermostat_type > p);

  // Constructors.
  //
  setting_t (const outputname_type&,
             const frequency_type&,
             const delta_t_type&,
             const t_end_type&,
             const b_factor_type&,
             const g_grav_x_type&,
             const g_grav_y_type&,
             const g_grav_z_type&,
             const domainX_type&,
             const domainY_type&,
             const domainZ_type&,
             const r_cutoff_type&,
             const bc_left_type&,
             const bc_upper_type&,
             const bc_right_type&,
             const bc_lower_type&,
             const bc_front_type&,
             const bc_back_type&);

  setting_t (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

  setting_t (const setting_t& x,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

  virtual setting_t*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  setting_t&
  operator= (const setting_t& x);

  virtual 
  ~setting_t ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< outputname_type > outputname_;
  endfile_optional endfile_;
  ::xsd::cxx::tree::one< frequency_type > frequency_;
  profileFile_optional profileFile_;
  profileBucketsX_optional profileBucketsX_;
  ::xsd::cxx::tree::one< delta_t_type > delta_t_;
  ::xsd::cxx::tree::one< t_end_type > t_end_;
  ::xsd::cxx::tree::one< b_factor_type > b_factor_;
  ::xsd::cxx::tree::one< g_grav_x_type > g_grav_x_;
  ::xsd::cxx::tree::one< g_grav_y_type > g_grav_y_;
  ::xsd::cxx::tree::one< g_grav_z_type > g_grav_z_;
  ::xsd::cxx::tree::one< domainX_type > domainX_;
  ::xsd::cxx::tree::one< domainY_type > domainY_;
  ::xsd::cxx::tree::one< domainZ_type > domainZ_;
  ::xsd::cxx::tree::one< r_cutoff_type > r_cutoff_;
  ContainerType_optional ContainerType_;
  ForceComputationMethod_optional ForceComputationMethod_;
  ::xsd::cxx::tree::one< bc_left_type > bc_left_;
  ::xsd::cxx::tree::one< bc_upper_type > bc_upper_;
  ::xsd::cxx::tree::one< bc_right_type > bc_right_;
  ::xsd::cxx::tree::one< bc_lower_type > bc_lower_;
  ::xsd::cxx::tree::one< bc_front_type > bc_front_;
  ::xsd::cxx::tree::one< bc_back_type > bc_back_;
  inputfiles_sequence inputfiles_;
  thermostat_optional thermostat_;
};

#include <iosfwd>

#include <xercesc/sax/InputSource.hpp>
#include <xercesc/dom/DOMDocument.hpp>
#include <xercesc/dom/DOMErrorHandler.hpp>

// Parse a URI or a local file.
//

::std::unique_ptr< ::setting_t >
setting (const ::std::string& uri,
         ::xml_schema::flags f = 0,
         const ::xml_schema::properties& p = ::xml_schema::properties ());

::std::unique_ptr< ::setting_t >
setting (const ::std::string& uri,
         ::xml_schema::error_handler& eh,
         ::xml_schema::flags f = 0,
         const ::xml_schema::properties& p = ::xml_schema::properties ());

::std::unique_ptr< ::setting_t >
setting (const ::std::string& uri,
         ::xercesc::DOMErrorHandler& eh,
         ::xml_schema::flags f = 0,
         const ::xml_schema::properties& p = ::xml_schema::properties ());

// Parse std::istream.
//

::std::unique_ptr< ::setting_t >
setting (::std::istream& is,
         ::xml_schema::flags f = 0,
         const ::xml_schema::properties& p = ::xml_schema::properties ());

::std::unique_ptr< ::setting_t >
setting (::std::istream& is,
         ::xml_schema::error_handler& eh,
         ::xml_schema::flags f = 0,
         const ::xml_schema::properties& p = ::xml_schema::properties ());

::std::unique_ptr< ::setting_t >
setting (::std::istream& is,
         ::xercesc::DOMErrorHandler& eh,
         ::xml_schema::flags f = 0,
         const ::xml_schema::properties& p = ::xml_schema::properties ());

::std::unique_ptr< ::setting_t >
setting (::std::istream& is,
         const ::std::string& id,
         ::xml_schema::flags f = 0,
         const ::xml_schema::properties& p = ::xml_schema::properties ());

::std::unique_ptr< ::setting_t >
setting (::std::istream& is,
         const ::std::string& id,
         ::xml_schema::error_handler& eh,
         ::xml_schema::flags f = 0,
         const ::xml_schema::properties& p = ::xml_schema::properties ());

::std::unique_ptr< ::setting_t >
setting (::std::istream& is,
         const ::std::string& id,
         ::xercesc::DOMErrorHandler& eh,
         ::xml_schema::flags f = 0,
         const ::xml_schema::properties& p = ::xml_schema::properties ());

// Parse xercesc::InputSource.
//

::std::unique_ptr< ::setting_t >
setting (::xercesc::InputSource& is,
         ::xml_schema::flags f = 0,
         const ::xml_schema::properties& p = ::xml_schema::properties ());

::std::unique_ptr< ::setting_t >
setting (::xercesc::InputSource& is,
         ::xml_schema::error_handler& eh,
         ::xml_schema::flags f = 0,
         const ::xml_schema::properties& p = ::xml_schema::properties ());

::std::unique_ptr< ::setting_t >
setting (::xercesc::InputSource& is,
         ::xercesc::DOMErrorHandler& eh,
         ::xml_schema::flags f = 0,
         const ::xml_schema::properties& p = ::xml_schema::properties ());

// Parse xercesc::DOMDocument.
//

::std::unique_ptr< ::setting_t >
setting (const ::xercesc::DOMDocument& d,
         ::xml_schema::flags f = 0,
         const ::xml_schema::properties& p = ::xml_schema::properties ());

::std::unique_ptr< ::setting_t >
setting (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
         ::xml_schema::flags f = 0,
         const ::xml_schema::properties& p = ::xml_schema::properties ());

#include <iosfwd>

#include <xercesc/dom/DOMDocument.hpp>
#include <xercesc/dom/DOMErrorHandler.hpp>
#include <xercesc/framework/XMLFormatter.hpp>

#include <xsd/cxx/xml/dom/auto-ptr.hxx>

void
operator<< (::xercesc::DOMElement&, const thermo_target_t&);

void
operator<< (::xercesc::DOMElement&, const thermo_t&);

void
operator<< (::xercesc::DOMElement&, const setting_t&);

// Serialize to std::ostream.
//

void
setting (::std::ostream& os,
         const ::setting_t& x, 
         const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
         const ::std::string& e = "UTF-8",
         ::xml_schema::flags f = 0);

void
setting (::std::ostream& os,
         const ::setting_t& x, 
         ::xml_schema::error_handler& eh,
         const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
         const ::std::string& e = "UTF-8",
         ::xml_schema::flags f = 0);

void
setting (::std::ostream& os,
         const ::setting_t& x, 
         ::xercesc::DOMErrorHandler& eh,
         const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
         const ::std::string& e = "UTF-8",
         ::xml_schema::flags f = 0);

// Serialize to xercesc::XMLFormatTarget.
//

void
setting (::xercesc::XMLFormatTarget& ft,
         const ::setting_t& x, 
         const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
         const ::std::string& e = "UTF-8",
         ::xml_schema::flags f = 0);

void
setting (::xercesc::XMLFormatTarget& ft,
         const ::setting_t& x, 
         ::xml_schema::error_handler& eh,
         const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
         const ::std::string& e = "UTF-8",
         ::xml_schema::flags f = 0);

void
setting (::xercesc::XMLFormatTarget& ft,
         const ::setting_t& x, 
         ::xercesc::DOMErrorHandler& eh,
         const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
         const ::std::string& e = "UTF-8",
         ::xml_schema::flags f = 0);

// Serialize to an existing xercesc::DOMDocument.
//

void
setting (::xercesc::DOMDocument& d,
         const ::setting_t& x,
         ::xml_schema::flags f = 0);

// Serialize to a new xercesc::DOMDocument.
//

::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument >
setting (const ::setting_t& x, 
         const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
         ::xml_schema::flags f = 0);

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

#endif // SETTING_H
